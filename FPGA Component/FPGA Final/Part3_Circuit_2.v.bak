module Part3_Circuit_2(data_in, clk, reset, data_out);
	//this is identical to the other Part3_Circuit but with 128 words
	input [23:0] data_in;
	input clk, reset;
	output reg [23:0] data_out;
	
	wire [23:0] data_in_FIFO, data_out_FIFO;
	wire [23:0] accumulate_in, accumulate_out;
        reg rdreq;
	reg [2:0] counter;
	
	//division by 128
	assign data_in_FIFO = data_in >> 7;

	//this block is generated by Quartus using basic functions
	FIFO_Quartus_2 FIFO_Quartus_2(.clock(clk),.data(data_in_FIFO),.sclr(reset),.wrreq(1'b1),.rdreq(rdreq),.q(data_out_FIFO));

	//this block controls the reading from the FIFO and establishes
	//the connections between the FIFO, accumulator, data input, and data output
	always @(posedge clk) begin
	  if (reset) begin
	    data_out <= 0;
	    rdreq <= 0;
	    counter <= 0;
	  end else begin
	    data_out <= data_in_FIFO + accumulate_out - data_out_FIFO;
	    //counter is nessesary due to lack of full output
	    if (counter != 7'b1111110) begin 
	      counter <= counter + 1;
	    end else begin
	      rdreq <= 1'b1;
	    end
	  end
	end
	
	//wire going into accumulator is different due to arthimetic 
	//since adding the output of the accumulator leads to infinite loop
	assign accumulate_in = data_in_FIFO - data_out_FIFO;

	//see accumulator documentation for more details
	Accumulator Accumulator(.clk(clk),.clear(reset),.d(accumulate_in),.q(accumulate_out));
endmodule
